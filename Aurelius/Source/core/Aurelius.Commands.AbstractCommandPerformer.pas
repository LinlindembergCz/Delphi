unit Aurelius.Commands.AbstractCommandPerformer;

{$I Aurelius.inc}

interface

uses
  Generics.Collections, DB,
  Aurelius.Commands.Listeners,
  Aurelius.Drivers.Interfaces,
  Aurelius.Mapping.Metadata,
  Aurelius.Mapping.Explorer,
  Aurelius.Sql.BaseTypes,
  Aurelius.Sql.Interfaces,
  Aurelius.Sql.Metadata;

type
  TAbstractSQLPerformer = class abstract
  strict private
    type
      TSQLPerformerWrapper = class(TInterfacedObject, ISQLPerformer)
      private
        FCommand: TAbstractSQLPerformer;
      public
        constructor Create(ACommand: TAbstractSQLPerformer);
        function Execute(SQL: string; Params: TList<TDBParam>; IsQuery: Boolean): IDBResultSet;
      end;
  strict private
    FClazz: TClass;
    FSQLGenerator: ISQLGenerator;
    FExplorer: TMappingExplorer;
  strict protected
    FEntityManager: TObject;
    FConnection: IDBConnection;
    FExecutionListeners: TList<ICommandExecutionListener>;
    function ReadFieldValue(ResultSet: IDBResultSet; FieldName: string; ClassFieldType: TFieldType): Variant;
    function GetSQLPerformer: ISQLPerformer;
    property Clazz: TClass read FClazz;
  protected
    function Execute(SQL: string; Params: TList<TDBParam>; IsQuery: Boolean): IDBResultSet;
    // Retrieves an interface for executing SQL queries.
    // The ISQLPerformer keeps a reference to this abstract command performer object.
    // So ne sure to not USe the ISQLPerformer interface after this object is destroyed
    property SQLGenerator: ISQLGenerator read FSQLGenerator;
    property Explorer: TMappingExplorer read FExplorer;
  public
    constructor Create; overload; virtual;
    destructor Destroy; override;
    procedure AddExecutionListener(Listener: ICommandExecutionListener);
    procedure AddExecutionListeners(Listeners: TEnumerable<ICommandExecutionListener>);
    procedure SetConnection(Conn: IDBConnection);
    procedure SetSQLGenerator(ASQLGenerator: ISQLGenerator);
    procedure SetClass(Clazz: TClass); virtual;
    procedure SetEntityManager(EntityManager: TObject);
    procedure SetExplorer(AExplorer: TMappingExplorer);
  end;

  TAbstractCommandPerformer = class abstract(TAbstractSQLPerformer)
  strict private
    type
      TCommandPerformerWrapper = class(TInterfacedObject, ICommandPerformer)
      private
        FCommand: TAbstractCommandPerformer;
      public
        constructor Create(ACommand: TAbstractCommandPerformer);
        function Execute(SQL: string; Params: TList<TDBParam>; IsQuery: Boolean): IDBResultSet;
        function CreateSQLTable: TSQLTable;
      end;
  strict private
    FDiscriminatorValues: TArray<Variant>;
    FDiscriminatorColumn: TColumn;
    FAlias: string;
    FHasJoinedTablesStrategy: boolean;
  strict protected
    FColumns: TList<TColumn>;
    FPKColumns: TArray<TColumn>;
    FAssociations: TList<TAssociation>;

    procedure MakeEquivalentColumn(Column: TColumnMetadata);
    procedure BuildColumnMetadata(Column: TColumnMetadata; C: TColumn);
    function CreateSQLTable: TSQLTable; virtual;
    function HasPrimaryJoinColumn: Boolean;
    function IsIdColumn(Col: TColumn): boolean;
    function IsAutoGeneratedColumn(Col: TColumn): boolean;
    function GetCommandPerformer: ICommandPerformer;
    property DiscriminatorColumn: TColumn read FDiscriminatorColumn;
    property DiscriminatorValues: TArray<Variant> read FDiscriminatorValues;
    property Alias: string read FAlias write FAlias;
    property HasJoinedTablesStrategy: boolean read FHasJoinedTablesStrategy;
  public
    constructor Create; override;
    procedure SetClass(Clazz: TClass); override;
  end;

  TSQLPerformer = class(TAbstractSQLPerformer)
  public
    procedure ExecuteSQL(SQL: string);
  end;

implementation

uses
  Variants, FMTBcd,
  Aurelius.Global.Utils,
  Aurelius.Global.Config,
  Aurelius.Sql.Exceptions;

{ TAbstractSQLPerformer }

procedure TAbstractSQLPerformer.AddExecutionListener(
  Listener: ICommandExecutionListener);
begin
  FExecutionListeners.Add(Listener);
end;

procedure TAbstractSQLPerformer.AddExecutionListeners(
  Listeners: TEnumerable<ICommandExecutionListener>);
begin
  FExecutionListeners.AddRange(Listeners);
end;

constructor TAbstractSQLPerformer.Create;
begin
  FExecutionListeners := TList<ICommandExecutionListener>.Create;
end;

destructor TAbstractSQLPerformer.Destroy;
begin
  FExecutionListeners.Free;
  inherited;
end;

function TAbstractSQLPerformer.Execute(SQL: string; Params: TList<TDBParam>;
  IsQuery: Boolean): IDBResultSet;
var
  Statement: IDBStatement;
  Listener: ICommandExecutionListener;
  P: TDBParam;
  E: TFieldTypeEquivalence;
  Found: Boolean;
begin
  FSQLGenerator.ProcessCommand(SQL);

  for Listener in FExecutionListeners do
    Listener.ExecutingCommand(SQL, Params);

  Statement := FConnection.CreateStatement;
  Statement.SetSQLCommand(SQL);

  if Params <> nil then
  begin
    for P in Params do
    begin
      if not (P.ParamType in FSQLGenerator.GetSupportedFieldTypes) then
      begin
        Found := False;
        for E in FSQLGenerator.GetEquivalentFieldTypes do
          if E.NotSupportedType = P.ParamType then
          begin
            Found := True;
            P.ParamType := E.EquivalentType;
            if P.ParamValue <> Variants.Null then
              P.ParamValue := FSQLGenerator.ConvertValue(
                P.ParamValue, E.NotSupportedType, E.EquivalentType);
            Break;
          end;
        if not Found then
          raise EUnsupportedFieldType.Create(FSQLGenerator, P.ParamType);
      end;
    end;

    Statement.SetParams(Params);
  end;

  Result := nil;
  if not TGlobalConfigs.GetInstance.SimuleStatements then
  begin
    if IsQuery then
      Result := Statement.ExecuteQuery
    else
      Statement.Execute;
  end;
end;

function TAbstractSQLPerformer.GetSQLPerformer: ISQLPerformer;
begin
  Result := TSQLPerformerWrapper.Create(Self);
end;

function TAbstractSQLPerformer.ReadFieldValue(ResultSet: IDBResultSet;
  FieldName: string; ClassFieldType: TFieldType): Variant;
var
  E: TFieldTypeEquivalence;
begin
  Result := ResultSet.GetFieldValue(FieldName);

  if Result <> Variants.Null then
  begin
    if not (ClassFieldType in FSQLGenerator.GetSupportedFieldTypes) then
    begin
      for E in FSQLGenerator.GetEquivalentFieldTypes do
        if E.NotSupportedType = ClassFieldType then
          Exit(FSQLGenerator.ConvertValue(Result, E.EquivalentType, E.NotSupportedType));

      raise EUnsupportedFieldType.Create(FSQLGenerator, ClassFieldType);
    end;
  end;
end;

procedure TAbstractSQLPerformer.SetExplorer(AExplorer: TMappingExplorer);
begin
  FExplorer := AExplorer;
end;

procedure TAbstractSQLPerformer.SetClass(Clazz: TClass);
begin
  FClazz := Clazz;
end;

procedure TAbstractSQLPerformer.SetConnection(Conn: IDBConnection);
begin
  FConnection := Conn;
end;

procedure TAbstractSQLPerformer.SetEntityManager(EntityManager: TObject);
begin
  FEntityManager := EntityManager;
end;

procedure TAbstractSQLPerformer.SetSQLGenerator(ASQLGenerator: ISQLGenerator);
begin
  FSQLGenerator := ASQLGenerator;
end;

{ TAbstractCommandPerformer }

constructor TAbstractCommandPerformer.Create;
begin
  inherited;
  FAlias := 'A';
end;

function TAbstractCommandPerformer.CreateSQLTable: TSQLTable;
var
  ATable: TMetaTable;
begin
  ATable := Explorer.GetTable(Clazz);

  Result := TSQLTable.Create(ATable.Name, ATable.Schema, FAlias);
end;

procedure TAbstractCommandPerformer.BuildColumnMetadata(
  Column: TColumnMetadata; C: TColumn);
begin
  Column.Name := C.Name;
  Column.NotNull := TColumnProp.Required in C.Properties;
  Column.FieldType := C.FieldType;
  Column.Length := C.Length;

  // specific code for memo. When length > 65535, field is considered to be memo, but actually
  // the size doesn't matter. So we must set this to zero otherwise database schema comparison will fail (size mismatch)
  if Column.FieldType in [ftMemo, ftWideMemo] then
    Column.Length := 0;
  Column.Precision := C.Precision;
  Column.Scale := C.Scale;
  Column.AutoGenerated := IsAutoGeneratedColumn(C) and (TDBFeature.AutoGenerated in SQLGenerator.SupportedFeatures);
  MakeEquivalentColumn(Column);
  SQLGenerator.DefineColumnType(Column);
end;

function TAbstractCommandPerformer.GetCommandPerformer: ICommandPerformer;
begin
  Result := TCommandPerformerWrapper.Create(Self);
end;

function TAbstractCommandPerformer.HasPrimaryJoinColumn: Boolean;
begin
  Result := Length(Explorer.GetPrimaryJoinColumns(Clazz)) > 0;
end;

function TAbstractCommandPerformer.IsAutoGeneratedColumn(Col: TColumn): boolean;
begin
  Result := Explorer.GetId(Clazz).IsAutoGenerated and IsIdColumn(Col);
end;

function TAbstractCommandPerformer.IsIdColumn(Col: TColumn): boolean;
var
  C: TColumn;
begin
  for C in Explorer.GetIdColumns(Self.Clazz) do
    if C = Col then
      Exit(true);
  Result := false;
end;

procedure TAbstractCommandPerformer.MakeEquivalentColumn(
  Column: TColumnMetadata);
var
  E: TFieldTypeEquivalence;
begin
  if not (Column.FieldType in SQLGenerator.GetSupportedFieldTypes) then
  begin
    for E in SQLGenerator.GetEquivalentFieldTypes do
      if E.NotSupportedType = Column.FieldType then
      begin
        Column.FieldType := E.EquivalentType;
        Column.Length := E.EquivalentLenth;
        Column.Precision := E.EquivalentPrecision;
        Column.Scale := E.EquivalentScale;
        Exit;
      end;

    raise EUnsupportedFieldType.Create(SQLGenerator, Column.FieldType);
  end;
end;

procedure TAbstractCommandPerformer.SetClass(Clazz: TClass);
var
  SubClasses: TList<TClass>;
  c: integer;
  SubClass: TClass;
begin
  inherited;

  FHasJoinedTablesStrategy := Explorer.HasInheritance(Clazz) and
    (Explorer.GetInheritanceStrategy(Clazz) = TInheritanceStrategy.JoinedTables);

  if HasJoinedTablesStrategy then
  begin
    FColumns := Explorer.GetColumns(Clazz, False, False);
    FPKColumns := Explorer.GetPrimaryJoinColumns(Clazz);

    if Length(FPKColumns) = 0 then
      FPKColumns := Explorer.GetIdColumns(Clazz);

    FAssociations := Explorer.GetAssociations(Clazz, True, False);
  end
  else
  begin
    FColumns := Explorer.GetColumns(Clazz, True, True);
    FPKColumns := Explorer.GetIdColumns(Clazz);
    FAssociations := Explorer.GetAssociations(Clazz, True, True);
  end;

  FDiscriminatorColumn := Explorer.GetDiscriminatorColumn(Clazz, True);

  // If we have a discriminator, then we must filter the select using the discriminator values
  // TODO: One exception is if current class is the root class for the hierarchy. In this case we won't filter
  // and we will accept all rows from the database (for optimization only).
  if FDiscriminatorColumn <> nil then
  begin
    // Get the discriminator values for all descendant classes
    SubClasses := TList<TClass>.Create;
    try
      for SubClass in Explorer.Hierarchy.GetAllSubClasses(Clazz) do
        SubClasses.Add(SubClass);
      SetLength(FDiscriminatorValues, SubClasses.Count + 1);
      FDiscriminatorValues[0] := TUtils.ValueToVariant(
        Explorer.GetDiscriminatorValue(Clazz));
      for c := 0 to SubClasses.Count - 1 do
        FDiscriminatorValues[c + 1] := TUtils.ValueToVariant(
          Explorer.GetDiscriminatorValue(SubClasses[c]));
    finally
      SubClasses.Free;
    end;
  end else
    SetLength(FDiscriminatorValues, 0);

  Explorer.CheckValidEntity(Clazz);
end;

{ TSQLPerfomer }

procedure TSQLPerformer.ExecuteSQL(SQL: string);
begin
  Execute(SQL, nil, False);
end;

{ TSQLPerformerWrapper }

constructor TAbstractSQLPerformer.TSQLPerformerWrapper.Create(ACommand: TAbstractSQLPerformer);
begin
  FCommand := ACommand;
end;

function TAbstractSQLPerformer.TSQLPerformerWrapper.Execute(SQL: string; Params: TList<TDBParam>;
  IsQuery: Boolean): IDBResultSet;
begin
  Result := FCommand.Execute(SQL, Params, IsQuery);
end;

{ TAbstractCommandPerformer.TCommandPerformerWrapper }

constructor TAbstractCommandPerformer.TCommandPerformerWrapper.Create(
  ACommand: TAbstractCommandPerformer);
begin
  FCommand := ACommand;
end;

function TAbstractCommandPerformer.TCommandPerformerWrapper.CreateSQLTable: TSQLTable;
begin
  Result := FCommand.CreateSQLTable;
end;

function TAbstractCommandPerformer.TCommandPerformerWrapper.Execute(SQL: string;
  Params: TList<TDBParam>; IsQuery: Boolean): IDBResultSet;
begin
  Result := FCommand.Execute(SQL, Params, IsQuery);
end;

end.
